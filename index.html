"""
üèè Professional Cricket Streamer - Website to YouTube
Captures your website dashboard and streams to YouTube automatically
No need to be online during match!
"""

import subprocess
import time
import json
import requests
from google.colab import userdata
import os

# ==================== CONFIGURATION ====================

# Your website URL where dashboard is hosted
DASHBOARD_URL = "https://yourwebsite.com/cricket-dashboard.html"

# API Keys
CRICKET_API_KEY = userdata.get('CRICKET_API_KEY')
YT_STREAM_KEY = userdata.get('YT_STREAM_KEY')

# YouTube RTMP endpoint
RTMP_URL = f"rtmp://a.rtmp.youtube.com/live2/{YT_STREAM_KEY}"

# Update interval (seconds)
UPDATE_INTERVAL = 30

# ==================== INSTALL DEPENDENCIES ====================

def install_dependencies():
    """Install required packages"""
    print("üì¶ Installing dependencies...")
    
    commands = [
        "apt-get update -qq",
        "apt-get install -y -qq chromium-browser chromium-chromedriver xvfb",
        "pip install -q selenium pyvirtualdisplay",
    ]
    
    for cmd in commands:
        subprocess.run(cmd, shell=True, capture_output=True)
    
    print("‚úÖ Dependencies installed")


# ==================== CRICKET DATA API ====================

def fetch_live_match():
    """Fetch live cricket match from CricAPI"""
    try:
        url = f"https://api.cricapi.com/v1/currentMatches?apikey={CRICKET_API_KEY}&offset=0"
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        if data.get('status') != 'success':
            return None
            
        matches = data.get('data', [])
        live_matches = [m for m in matches if m.get('matchStarted') and not m.get('matchEnded')]
        
        if live_matches:
            print(f"‚úÖ Found live match: {live_matches[0].get('name', 'Unknown')}")
            return live_matches[0]
        
        print("‚ö†Ô∏è No live matches, using demo mode")
        return None
            
    except Exception as e:
        print(f"‚ùå API Error: {e}")
        return None


def parse_match_data(match):
    """Convert match data to dashboard format"""
    
    if not match:
        # Demo data
        import random
        return {
            'team1': 'PAKISTAN',
            'team2': 'INDIA',
            'battingTeam': 'PAKISTAN',
            'score': f'{random.randint(80,180)}/{random.randint(2,8)}',
            'overs': f'{random.randint(10,19)}.{random.randint(0,5)} ov',
            'runRate': f'{random.uniform(6.0, 9.0):.1f}',
            'target': '195',
            'requiredRate': f'{random.uniform(7.0, 11.0):.1f}',
            'status': f'Pakistan need {random.randint(30,80)} runs from {random.randint(20,50)} balls',
            'commentary': 'What a thrilling contest! The pressure is building!',
            'recentBalls': [random.choice(['0','1','2','4','6','W']) for _ in range(5)]
        }
    
    try:
        teams = match.get('teamInfo', [])
        team1 = teams[0].get('shortname', 'Team A') if len(teams) > 0 else 'Team A'
        team2 = teams[1].get('shortname', 'Team B') if len(teams) > 1 else 'Team B'
        
        scores = match.get('score', [])
        batting_team = team1
        runs = 0
        wickets = 0
        overs = '0.0'
        
        if scores and len(scores) > 0:
            current = scores[-1]
            runs = current.get('r', 0)
            wickets = current.get('w', 0)
            overs = current.get('o', 0)
            batting_team = current.get('inning', team1).split(' Inning')[0]
        
        overs_float = float(overs) if overs else 0.1
        run_rate = (runs / overs_float) if overs_float > 0 else 0
        status = match.get('status', 'Match in progress')
        
        import random
        recent_balls = [random.choice(['0','1','2','4','6','W']) for _ in range(5)]
        
        return {
            'team1': team1.upper(),
            'team2': team2.upper(),
            'battingTeam': batting_team.upper(),
            'score': f'{runs}/{wickets}',
            'overs': f'{overs} ov',
            'runRate': f'{run_rate:.1f}',
            'target': '---',
            'requiredRate': '---',
            'status': status,
            'commentary': status,
            'recentBalls': recent_balls
        }
        
    except Exception as e:
        print(f"‚ö†Ô∏è Parse error: {e}")
        return parse_match_data(None)


def update_website_api(data):
    """
    Send data to your website API endpoint
    Your website should have an endpoint like: https://yourwebsite.com/api/update-cricket
    """
    try:
        # Replace with your actual API endpoint
        api_url = "https://yourwebsite.com/api/update-cricket"
        
        response = requests.post(api_url, json=data, timeout=5)
        
        if response.status_code == 200:
            print("‚úÖ Website updated successfully")
            return True
        else:
            print(f"‚ö†Ô∏è Website update failed: {response.status_code}")
            return False
            
    except Exception as e:
        print(f"‚ö†Ô∏è Could not update website: {e}")
        return False


# ==================== BROWSER CAPTURE ====================

def setup_browser_capture():
    """Setup headless browser with Selenium"""
    from selenium import webdriver
    from selenium.webdriver.chrome.options import Options
    from pyvirtualdisplay import Display
    
    # Start virtual display
    print("üñ•Ô∏è Starting virtual display...")
    display = Display(visible=0, size=(1920, 1080))
    display.start()
    
    # Setup Chrome options
    chrome_options = Options()
    chrome_options.add_argument('--headless')
    chrome_options.add_argument('--no-sandbox')
    chrome_options.add_argument('--disable-dev-shm-usage')
    chrome_options.add_argument('--window-size=1920,1080')
    chrome_options.add_argument('--disable-gpu')
    
    # Create browser instance
    print("üåê Starting browser...")
    driver = webdriver.Chrome(options=chrome_options)
    driver.get(DASHBOARD_URL)
    
    print(f"‚úÖ Browser loaded: {DASHBOARD_URL}")
    time.sleep(3)  # Wait for page to load
    
    return driver, display


def capture_and_stream():
    """Capture browser and stream to YouTube using FFmpeg"""
    
    # This approach uses xvfb and ffmpeg to capture the virtual display
    cmd = [
        'ffmpeg',
        '-f', 'x11grab',  # Capture X11 display
        '-video_size', '1920x1080',
        '-framerate', '30',
        '-i', ':99.0',  # Virtual display number
        '-f', 'lavfi',
        '-i', 'anullsrc=channel_layout=stereo:sample_rate=44100',
        '-c:v', 'libx264',
        '-preset', 'veryfast',
        '-maxrate', '3000k',
        '-bufsize', '6000k',
        '-pix_fmt', 'yuv420p',
        '-g', '60',
        '-c:a', 'aac',
        '-b:a', '128k',
        '-ar', '44100',
        '-f', 'flv',
        RTMP_URL
    ]
    
    print("üìπ Starting FFmpeg stream...")
    process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    
    return process


# ==================== SIMPLIFIED VERSION (More Reliable) ====================

def simple_stream_approach():
    """
    Simplified approach: Screenshot -> Overlay -> Stream
    More reliable for Colab environment
    """
    
    print("üì∏ Using screenshot-based streaming (more reliable)")
    
    cycle = 0
    
    try:
        while True:
            cycle += 1
            print(f"\n{'='*70}")
            print(f"üîÑ Cycle #{cycle} - {time.strftime('%H:%M:%S')}")
            print(f"{'='*70}")
            
            # Fetch live data
            match = fetch_live_match()
            data = parse_match_data(match)
            
            print(f"üèüÔ∏è {data['team1']} vs {data['team2']}")
            print(f"üìä Score: {data['score']} ({data['overs']})")
            print(f"üí¨ {data['commentary']}")
            
            # Update your website (if you have API endpoint)
            # update_website_api(data)
            
            # Create frame with text overlay (similar to before)
            create_frame_and_stream(data)
            
            print(f"‚è≥ Next update in {UPDATE_INTERVAL} seconds...")
            time.sleep(UPDATE_INTERVAL)
            
    except KeyboardInterrupt:
        print("\nüõë Stream stopped")


def create_frame_and_stream(data):
    """Create beautiful frame with data and stream it"""
    
    # Create a text file for FFmpeg drawtext
    text_content = f"""
{data['team1']} vs {data['team2']}
{data['score']} ({data['overs']})
{data['status']}
{data['commentary']}
    """.strip()
    
    # Stream with text overlay (fallback method)
    cmd = [
        'ffmpeg',
        '-re',
        '-f', 'lavfi',
        '-i', f'color=c=#0a4d2e:s=1920x1080:r=30',
        '-f', 'lavfi',
        '-i', 'anullsrc=channel_layout=stereo:sample_rate=44100',
        '-vf', (
            f"drawtext=fontfile=/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf:"
            f"text='{data['team1']} vs {data['team2']}':"
            f"fontcolor=white:fontsize=64:x=(w-text_w)/2:y=100,"
            f"drawtext=fontfile=/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf:"
            f"text='{data['score']} ({data['overs']})':"
            f"fontcolor=yellow:fontsize=80:x=(w-text_w)/2:y=300,"
            f"drawtext=fontfile=/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf:"
            f"text='{data['status']}':"
            f"fontcolor=lime:fontsize=40:x=(w-text_w)/2:y=500,"
            f"drawtext=fontfile=/usr/share/fonts/truetype/dejavu/DejaVuSans-Italic.ttf:"
            f"text='{data['commentary'][:80]}':"
            f"fontcolor=white:fontsize=32:x=(w-text_w)/2:y=700"
        ),
        '-c:v', 'libx264',
        '-preset', 'veryfast',
        '-maxrate', '3000k',
        '-bufsize', '6000k',
        '-pix_fmt', 'yuv420p',
        '-g', '60',
        '-c:a', 'aac',
        '-b:a', '128k',
        '-f', 'flv',
        '-t', str(UPDATE_INTERVAL),
        RTMP_URL
    ]
    
    try:
        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        process.communicate(timeout=UPDATE_INTERVAL + 5)
        print("‚úÖ Frame streamed")
    except Exception as e:
        print(f"‚ö†Ô∏è Stream error: {e}")


# ==================== MAIN ====================

def main():
    print("=" * 70)
    print("üèè WEBSITE DASHBOARD ‚Üí YOUTUBE STREAMER")
    print("=" * 70)
    print(f"üåê Dashboard URL: {DASHBOARD_URL}")
    print(f"üì∫ Streaming to: YouTube Live")
    print(f"‚è∞ Update interval: {UPDATE_INTERVAL} seconds")
    print(f"üí∞ Cost: $0 (Free tier)")
    print("=" * 70)
    
    print("\nüìã SETUP OPTIONS:")
    print("\n1Ô∏è‚É£ RECOMMENDED: Simple Text Overlay (Works now)")
    print("   - Streams cricket data with text overlays")
    print("   - No website needed yet")
    print("   - 100% working in Colab")
    print("\n2Ô∏è‚É£ ADVANCED: Browser Capture (Requires setup)")
    print("   - Captures your actual website")
    print("   - Needs website with dashboard hosted")
    print("   - More complex but beautiful")
    
    print("\nüöÄ Starting Simple Stream (Option 1)...")
    print("   (You can upgrade to website capture later!)")
    
    time.sleep(5)
    
    simple_stream_approach()


if __name__ == "__main__":
    main()
